import torch
import torch.nn as nn
import numpy as np
import matplotlib.pyplot as plt
import time

def f(x,y):
    return 200*(y*(1 - y) + x*(1 - x))
def u_accuracy(x,y):
    return 100*x*(1 - x)*y*(1 - y)
def u_boundary(x,y):
    return 0*x*y
xa,xb = 0,1
ya,yb = 0,1
'''
def f(x,y):#微分方程的右边函数f
    return - (2*np.pi**2)*np.exp(np.pi*(x + y))*np.sin(np.pi*(x + y))
def u_accuracy(x,y):
    return np.exp(np.pi*(x + y))*np.sin(np.pi*x)*np.sin(np.pi*y)
def u_boundary(x,y):
    return u_accuracy(x,y)
xa,xb = 0.8,1.8
ya,yb = -0.8,0
'''

def kernel(x,y):
    x_ = (x - xa)/(xb - xa)
    y_ = (y - ya)/(yb - ya)
    h = (xb - xa)**2 + (yb - ya)**2
    return np.exp(-(x_**2 + y_**2)/(2*h))
class INSET():
    def __init__(self):
        self.dim = 2
        self.xa,self.xb = xa,xb
        self.ya,self.yb = ya,yb
        self.nx,self.ny = 20,30
        self.hx = (self.xb - self.xa)/self.nx
        self.hy = (self.yb - self.ya)/self.ny
        self.size = self.nx*self.ny
        self.X = torch.zeros(self.size,self.dim)
        for i in range(self.nx):
            for j in range(self.ny):
                self.X[i*self.ny + j,0] = self.xa + (i + 0.5)*self.hx
                self.X[i*self.ny + j,1] = self.ya + (j + 0.5)*self.hy
        self.u_acc = u_accuracy(self.X[:,0],self.X[:,1]).view(-1,1)
        self.right = f(self.X[:,0],self.X[:,1]).view(-1,1)
        self.ker = kernel(self.X[:,0],self.X[:,1]).view(-1,1)
        self.ub = u_boundary(self.X[:,0],self.X[:,1]).view(-1,1)
class BDSET():
    def __init__(self):
        self.dim = 2
        self.xa,self.xb = xa,xb
        self.ya,self.yb = ya,yb
        self.nx,self.ny = 20,30
        self.hx = (self.xb - self.xa)/self.nx
        self.hy = (self.yb - self.ya)/self.ny
        self.size = 2*(self.nx + self.ny)
        self.X = torch.zeros(self.size,self.dim)
        for i in range(self.nx):
            for j in range(self.ny):
                self.X[i,0] = self.xa + (i + 0.5)*self.hx
                self.X[i,1] = self.ya
                self.X[self.nx + j,0] = self.xb
                self.X[self.nx + j,1] = self.ya + (j + 0.5)*self.hy
                self.X[self.nx + self.ny + i,0] = self.xb - self.xa - (i + 0.5)*self.hx
                self.X[self.nx + self.ny + i,1] = self.yb
                self.X[2*self.nx + self.ny + j,0] = self.xa
                self.X[2*self.nx + self.ny + j,1] = self.yb - self.ya - (j + 0.5)*self.hy
        self.ker = kernel(self.X[:,0],self.X[:,1]).view(-1,1)
        self.ub = u_boundary(self.X[:,0],self.X[:,1]).view(-1,1)
class TESET():
    def __init__(self):
        self.dim = 2
        self.xa,self.xb = xa,xb
        self.ya,self.yb = ya,yb
        self.hx = 0.1
        self.hy = 0.05
        self.nx = int((self.xb - self.xa)/self.hx) + 1
        self.ny = int((self.yb - self.ya)/self.hy) + 1
        self.size = self.nx*self.ny
        self.X = torch.zeros(self.size,self.dim)
        for j in range(self.ny):
            for i in range(self.nx):
                self.X[j*self.nx + i,0] = self.xa + i*self.hx
                self.X[j*self.nx + i,1] = self.ya + j*self.hy
        self.u_acc = u_accuracy(self.X[:,0],self.X[:,1]).view(-1,1)
        self.ker = kernel(self.X[:,0],self.X[:,1]).view(-1,1)
        self.ub = u_boundary(self.X[:,0],self.X[:,1]).view(-1,1)
np.random.seed(1234)
torch.manual_seed(1234)
class Res(nn.Module):
    def __init__(self,input_size,output_size):
        super(Res,self).__init__()
        self.model = nn.Sequential(
            nn.Linear(input_size,output_size),
            nn.Tanh(),
            nn.Linear(output_size,output_size),
            nn.LeakyReLU(inplace = True)
        )
        self.input = input_size
        self.output = output_size
    def forward(self,x):
        x = self.model(x) + x@torch.eye(x.shape[1],self.output)
        return x
class NET(nn.Module):
    def __init__(self):
        super(NET,self).__init__()
        self.model = nn.Sequential(
            Res(2,10),
            Res(10,1)
        )   
    def forward(self,x):
        return self.model(x)
def pred(net,model):
    mi = torch.tensor([[xa,ya]]).float()
    ma = torch.tensor([[xb,yb]]).float()
    H = 2*(model.X - mi)/(ma - mi) - 1
    return net.forward(H)
    #return net.forward(model.X)
def error(net,model):
    fenzi = ((pred(net,model) - model.u_acc)**2).detach().numpy().sum()
    fenmu = (model.u_acc**2 + 1e-7).detach().numpy().sum()
    return np.sqrt(fenzi/fenmu)
def LOSS(net,inset,bdset,belta):
    x_in = inset.X
    x_in.requires_grad = True
    u_in = pred(net,inset)
    ux, = torch.autograd.grad(u_in,x_in,create_graph = True,retain_graph = True,
                                  grad_outputs = torch.ones(inset.size,1))
    ub = pred(net,bdset)
    return 0.5*(ux[:,0:1]**2 + ux[:,1:2]**2 - 2*inset.right*u_in).sum()\
            + belta*((bdset.ub - ub)**2).sum()
def train(net,inset,bdset,teset,belta,optim,epochs,step,record):
    BUZHOU = []
    ERROR = []
    for i in range(epochs):
        print('train neural network')
        st = time.time()
        for j in range(step):
            optim.zero_grad()
            loss = LOSS(net,inset,bdset,belta)
            loss.backward()
            optim.step()
            if j%record == 0:
                trainerror = error(net,inset)
                teseterror = error(net,teset)
                BUZHOU.append(j + i*step)
                ERROR.append(teseterror)
                print('epoch:%d,step:%d,loss:%.3e,train error:%.3f'%
                      (i,j,loss.item(),trainerror))
        alt = time.time() - st
        print('one epoch use time:%.2f,test error:%.3f'%
             (alt,error(net,teset)))
        print('-----------------------------------------------------')
    return BUZHOU,ERROR
net = NET()
inset = INSET()
bdset = BDSET()
teset = TESET()
optim = torch.optim.Adam(net.parameters(),lr = 5e-3)
belta = 5e2
epochs = 3
step = 1000
record = 250

BUZHOU,OLDERROR = train(net,inset,bdset,teset,belta,optim,epochs,step,record)
M,N = teset.nx,teset.ny
x_train = np.linspace(teset.xa,teset.xb,M)
y_train = np.linspace(teset.ya,teset.yb,N)
x,y = np.meshgrid(x_train,y_train)
u_pred = pred(net,teset).detach().numpy().reshape(N,M)
plt.contourf(x,y,u_pred,40,cmap = 'Blues')
plt.colorbar()
plt.xlabel('x')
plt.ylabel('y')
plt.title('DRM solution')
plt.savefig('DRM.jpg')
def newpred(net,model):
    mi = torch.tensor([[xa,ya]]).float()
    ma = torch.tensor([[xb,yb]]).float()
    H = 2*(model.X - mi)/(ma - mi) - 1
    return net.forward(H)*model.ker + model.ub
    #return net.forward(model.X)*model.ker + model.ub
    
def newerror(net,model):
    fenzi = ((newpred(net,model) - model.u_acc)**2).detach().numpy().sum()
    fenmu = (model.u_acc**2 + 1e-8).detach().numpy().sum()
    return np.sqrt(fenzi/fenmu)
def NEWLOSS(net,inset,bdset,belta):
    x_in = inset.X
    x_in.requires_grad = True
    u_in = newpred(net,inset)
    ux, = torch.autograd.grad(u_in,x_in,create_graph = True,retain_graph = True,
                                  grad_outputs = torch.ones(inset.size,1))
    ub = newpred(net,bdset)
    return 0.5*(ux[:,0:1]**2 + ux[:,1:2]**2 - 2*inset.right*u_in).sum()\
            + belta*((bdset.ub - ub)**2).sum()
def newtrain(net,inset,bdset,teset,belta,optim,epochs,step,record):
    BUZHOU = []
    ERROR = []
    for i in range(epochs):
        print('train neural network')
        st = time.time()
        for j in range(step):
            optim.zero_grad()
            loss = NEWLOSS(net,inset,bdset,belta)
            loss.backward()
            optim.step()
            if j%record == 0:
                trainerror = newerror(net,inset)
                teseterror = newerror(net,teset)
                BUZHOU.append(j + i*step)
                ERROR.append(teseterror)
                print('epoch:%d,step:%d,loss:%.3e,train error:%.3f'%
                      (i,j,loss.item(),trainerror))
        alt = time.time() - st
        print('one epoch use time:%.2f,test error:%.3f'%
             (alt,newerror(net,teset)))
        print('-----------------------------------------------------')
    return BUZHOU,ERROR
newnet = NET()
inset = INSET()
bdset = BDSET()
teset = TESET()
optim = torch.optim.Adam(newnet.parameters(),lr = 5e-3)

BUZHOU,NEWERROR = newtrain(newnet,inset,bdset,teset,belta,optim,epochs,step,record)
M,N = teset.nx,teset.ny
x_train = np.linspace(teset.xa,teset.xb,M)
y_train = np.linspace(teset.ya,teset.yb,N)
x,y = np.meshgrid(x_train,y_train)
u_pred = newpred(newnet,teset).detach().numpy().reshape(N,M)
plt.contourf(x,y,u_pred,40,cmap = 'Blues')
plt.colorbar()
plt.xlabel('x')
plt.ylabel('y')
plt.title('the new solution')
plt.savefig('new.jpg')
plt.plot(BUZHOU,OLDERROR,'r*')
plt.plot(BUZHOU,OLDERROR,'b-',label = 'DRM',linewidth = 2)
plt.plot(BUZHOU,NEWERROR,'ko')
plt.plot(BUZHOU,NEWERROR,'g-',label = 'new method',linewidth = 2)
plt.xlabel('epoch')
plt.ylabel('error')
plt.legend()
plt.savefig('error.jpg')
