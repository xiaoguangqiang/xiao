import torch
import numpy as np
import matplotlib.pyplot as plt
def UU(prob,X):
    if prob == 1:
        return X[:,0]*X[:,0]*(1 - X[:,0]*X[:,0])*X[:,1]*X[:,1]*(X[:,1]*X[:,1] - 1)
    if prob == 2:
        return (X[:,0] + X[:,1]**3)*np.exp(-X[:,0])
    if prob == 3:
        return (X[:,0]**2 + X[:,1]**2)
def f(prob,X):
    if prob == 1:
        return 2*((1 - 6*X[:,0]**2)*X[:,1]*X[:,1]*(1 - X[:,1]**2) \
                 + (1 - 6*X[:,1]**2)*X[:,0]*X[:,0]*(1 - X[:,0]**2))
    if prob == 2:
        return (X[:,1]**3 + 6*X[:,1] + X[:,0] - 2)*np.exp(X[:,0])
    if prob == 3:
        return - 4*np.exp(X[:,0])*np.exp(-X[:,0])
class TRSET():
    def __init__(self,bound,nx,prob):
        self.hx = [(bound[0,1] - bound[0,0])/(nx[0] - 1),(bound[1,1] - bound[1,0])/(nx[1] - 1)]
        self.X = torch.zeros(nx[1]*nx[0],2)
        for j in range(nx[1]):
            for i in range(nx[0]):
                self.X[j*nx[0] + i,0] = bound[0,0] + i*self.hx[0]
                self.X[j*nx[0] + i,1] = bound[1,0] + j*self.hx[1]
        self.u_acc = UU(prob,self.X).view(-1,1)
        self.right = f(prob,self.X).view(-1,1)
bound = torch.tensor([[0,1],[0,1]]).float()
nx = [15,25]
prob = 2
trset = TRSET(bound,nx,prob)
#---------------------------------------------
#定义系数矩阵和右端项
A = torch.zeros(nx[0]*nx[1],nx[0]*nx[1])
#A = D - L - U
D = np.zeros_like(A)
L = np.zeros_like(A)
U = np.zeros_like(A)
for j in range(nx[1]):
    for i in range(nx[0]):
        if i == 0 or i == nx[0] - 1 or j == 0 or j == nx[1] - 1:
            A[j*nx[0] + i,j*nx[0] + i] = 1
            D[j*nx[0] + i,j*nx[0] + i] = A[j*nx[0] + i,j*nx[0] + i]
        else:
            A[j*nx[0] + i,j*nx[0] + i] = 2*(trset.hx[0]/trset.hx[1] + trset.hx[1]/trset.hx[0])
            D[j*nx[0] + i,j*nx[0] + i] = A[j*nx[0] + i,j*nx[0] + i]
            #--------------------------------
            A[j*nx[0] + i,j*nx[0] + i - 1] = -trset.hx[1]/trset.hx[0]
            L[j*nx[0] + i,j*nx[0] + i - 1] = - A[j*nx[0] + i,j*nx[0] + i - 1]
            #--------------------------------------
            A[j*nx[0] + i,j*nx[0] + i + 1] = -trset.hx[1]/trset.hx[0]
            U[j*nx[0] + i,j*nx[0] + i + 1] = - A[j*nx[0] + i,j*nx[0] + i + 1]
            #---------------------------------------
            A[j*nx[0] + i,(j - 1)*nx[0] + i] = -trset.hx[0]/trset.hx[1]
            L[j*nx[0] + i,(j - 1)*nx[0] + i] = - A[j*nx[0] + i,(j - 1)*nx[0] + i]
            #----------------------------------------
            A[j*nx[0] + i,(j + 1)*nx[0] + i] = -trset.hx[0]/trset.hx[1]
            U[j*nx[0] + i,(j + 1)*nx[0] + i] = - A[j*nx[0] + i,(j + 1)*nx[0] + i]
            
b = torch.zeros(nx[1]*nx[0],1)
for j in range(nx[1]):
    y = j*trset.hx[1]
    for i in range(nx[0]):
        x = i*trset.hx[0]
        X = torch.tensor([[x,y]]).float()
        if i == 0 or i == nx[0] - 1 or j == 0 or j == nx[1] - 1:
            b[j*nx[0] + i,0] = UU(prob,X)
        else:
            b[j*nx[0] + i,0] = trset.hx[0]*trset.hx[1]*f(prob,X)

#-------------------------------------------------------------
#超松弛迭代法 
omega = 1
MI = np.dot(np.linalg.inv(D - omega*L),(1 - omega)*D + omega*U)
BI = omega*np.dot(np.linalg.inv(D - omega*L),b)
x = np.random.rand(nx[0]*nx[1],1)
eps = 1e-4
def SOR(x,n,eps):
    for i in range(n):
        x_old = x
        x = np.dot(MI,x_old) + BI
        if max(abs(x - x_old)) < eps:
            break
    print(i)
    return x
u_pred = SOR(x,1000,1e-9)
def error(u_pred,u_acc):
    fenzi = ((u_pred - u_acc)**2).sum()
    fenmu = (u_acc**2 + 1e-6).sum()
    return np.sqrt(fenzi/fenmu)

print(error(u_pred,trset.u_acc.numpy()))

x_train = np.linspace(bound[0,0],bound[0,1],nx[0])
y_train = np.linspace(bound[1,0],bound[1,1],nx[1])
x,y = np.meshgrid(x_train,y_train)
print(x.shape)
print(x_train)
plt.contourf(x,y,u_pred.reshape(nx[1],nx[0]),40,cmap = 'Blues')
plt.colorbar()
plt.xlabel('x')
plt.ylabel('y')
plt.title('the FD solution')
#plt.savefig('FD.jpg')
